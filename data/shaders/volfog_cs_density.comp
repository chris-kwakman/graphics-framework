#version 430

layout(local_size_x = 10, local_size_y = 10, local_size_z = 8) in;
const uint MAX_VOLFOG_INSTANCES = 256;

struct VolumetricFogInstance
{
    mat4    u_inv_m;
    float   u_density;
    float   u_density_attenuation;  // How density attenuates over height (i.e. distance from bottom of boundary box)
};

layout(std430, binding = 0) readonly buffer ssbo_volfog_instance_data
{
    VolumetricFogInstance volfog_instances[];
};

layout(binding = 0) uniform ubo_fogcam
{
    // Do not reorder
    mat4 u_fog_cam_inv_vp;
    vec3 u_fog_cam_view_dir;
    float u_fog_cam_near;
    vec3 u_world_pos;
    float u_fog_cam_far;
    float u_layer_linearity;
};

uniform image3D writeonly out_density;

shared VolumetricFogInstance shared_volfog_instances[MAX_VOLFOG_INSTANCES];
shared uint shared_volfog_instance_count = 0;

vec3 get_normalized_thread_global_id()
{
    return vec3(gl_GlobalInvocationID) / vec3(imageSize(out_density) - 1);
}

vec3 get_thread_ndc_pos()
{
    const vec3 offset = vec3(1.0) / imageSize(out_density);
    const vec3 ndc_min = vec3(-1)+offset;
    const vec3 ndc_max = vec3(1)-offset;
    const vec3 normalized_pos = get_normalized_thread_global_id();
    return ndc_min * (1-normalized_pos) + ndc_max * normalized_pos;
}

float linearize_value(float t, float a, float b, float linearity)
{  
    return (1 - linearity) * (a * pow(b / a, t)) + linearity * (a + t * (b-a));
}

// Uniformly distributes volumetric texel space into world space.
vec4 compute_thread_world_pos()
{
    vec3 normalized_global_id = get_normalized_thread_global_id();
    
    // Rather than using converting normalized [0,1] Z of thread global id to 
    // NDC directly, we first compute view depth, convert to ndc depth,
    // and use new ndc depth with NDC position to get proper world position.
    float n = u_fog_cam_near;
    float f = u_fog_cam_far;
    float view_depth = linearize_value(normalized_global_id.z, n, f, u_layer_linearity);
    float ndc_z = (f + n - (2*n*f)/view_depth)/(f-n);

    // Convert NDC to world position
    vec3 ndc_pos = vec3(get_thread_ndc_pos().xy, ndc_z);
    vec4 world_pos = u_fog_cam_inv_vp * vec4(ndc_pos, 1);
    return world_pos / world_pos.w;
}

void main(void)
{
    // Have the first local thread in a given workgroup copy
    // copy volumetric fog instance data to shared array.

    if(any(greaterThan(get_normalized_thread_global_id(), vec3(1))))
        return;

    if(gl_LocalInvocationIndex == 0)
    {
        shared_volfog_instance_count = volfog_instances.length();
        for(uint i = 0; i < shared_volfog_instance_count; ++i)
        {
            shared_volfog_instances[i] = volfog_instances[i];
        }
    }
    memoryBarrier();
    barrier();

    // Convert global invocation ID to position in NDC space.

    // Outdated technique: Sampling linearly in NDC space, then transforming point into
    // world space where points will be exponentially distributed.

    // Bring NDC position of current thread to world position.
    // vec4 world_pos = u_fog_cam_inv_vp * vec4(ndc_pos,1);
    // world_pos /= world_pos.w;

    // New technique: Sampling linearly in view space, then transforming point into
    // world space where points will also be linearly distributed.

    const vec4 world_pos = compute_thread_world_pos();

    // Iterate through volumetric fog instances
    // Bring world position of thread to local space of each instance, and test if it
    // lies inside the boundaries of the model.
    
    // TODO: Chose type of boundary depending on type of shape of volumetric fog instance.
    // Sphere: Test if distance from (0,0,0) in local space is lower than radius.
    // Cuboid: Test if local space position is within [-1,1] boundary on all axes.

    float write_fog_density = 0.0;
    for(unsigned int i = 0; i < shared_volfog_instance_count; ++i)
    {
        VolumetricFogInstance instance = shared_volfog_instances[i];
        const vec4 fog_pos = instance.u_inv_m * world_pos;
        // Assume cuboid for now.
        if(all(greaterThan(fog_pos.xyz, vec3(-1)) && lessThan(fog_pos.xyz, vec3(1))))
        {
            float fog_bottom = (inverse(instance.u_inv_m) * vec4(fog_pos.x,-1,fog_pos.z,1)).y;
            float height = max(world_pos.y - fog_bottom,0);
            float uniform_density = instance.u_density * exp(-height*instance.u_density_attenuation);
            write_fog_density += uniform_density;
        }
    }
    // TODO: Temporal variation using perlin noise varying over time.

    // Store accumulated data of fog instances into texture at texel corresponding to local thread's sampled texel.
    write_fog_density = max(write_fog_density, 0);
    imageStore(out_density, ivec3(gl_GlobalInvocationID), vec4(write_fog_density,0,0,0));
}