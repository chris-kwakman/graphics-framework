#version 430

layout(local_size_x = 10, local_size_y = 10, local_size_z = 8) in;
const uint MAX_VOLFOG_INSTANCES = 256;

struct VolumetricFogInstance
{
    mat4x4  u_inv_m;
    float   u_density;
    float   u_density_attenuation;  // How density attenuates over height (i.e. distance from bottom of boundary box)
};

layout(binding = 0)uniform ubo_fogcam
{
    // Do not reorder
    mat4 u_fog_cam_inv_vp;
    vec3 u_fog_cam_view_dir;
    float u_fog_cam_near;
    vec3 u_fog_cam_world_pos;
    float u_fog_cam_far;
};

layout(binding = 1) uniform ubo_shader_properties
{
	vec3	u_fog_albedo;
	float	u_scattering_coefficient;
	float	u_absorption_coefficient;
	float	u_phase_anisotropy;
};

uniform vec3 u_sun_dir;
uniform uint u_pointlight_count;

layout(r16f) uniform image3D readonly u_in_density;
uniform image3D writeonly u_out_inscattering;

layout(std430, binding = 0) readonly buffer ssbo_volfog_instance_data
{
    VolumetricFogInstance volfog_instances[];
};

vec3 get_normalized_thread_global_id()
{
    return vec3(gl_GlobalInvocationID) / vec3(imageSize(u_out_inscattering) - 1);
}

vec3 get_thread_ndc_pos()
{
    return get_normalized_thread_global_id() * 2 - 1;
}

// Uniformly distributes volumetric texel space into world space.
vec4 compute_thread_world_pos()
{
    vec3 normalized_global_id = get_normalized_thread_global_id();
    vec3 ndc_pos = get_thread_ndc_pos();
    vec4 world_near = u_fog_cam_inv_vp * vec4(ndc_pos.xy, -1.0, 1.0);
    world_near /= world_near.w;
    vec4 world_far = u_fog_cam_inv_vp * vec4(ndc_pos.xy, 1.0, 1.0);
    world_far /= world_far.w;
    return world_far * normalized_global_id.z + world_near * (1.0 - normalized_global_id.z);
}

#define M_PI 3.1415926535897932384626433832795

// Thickness of slice - non-constant due to exponential slice distrubtion.
// TODO: Slice distribution IS constant, so the above is not actually true.
float compute_layer_thickness(vec3 _world_pos)
{
    // TODO: Convert to using exponential depth (if ever)
    return imageSize(u_in_density).z;
}

// Estimated density of participating medium at given point.
float calculate_density_function(vec3 _world_pos)
{
    return imageLoad(
        u_in_density, 
        ivec3(get_normalized_thread_global_id() * imageSize(u_in_density))
    ).r;
}

float get_sun_lighting_radiance(vec3 _world_pos)
{
    return 0.0;
}

float get_phase_function(vec3 _view_dir, vec3 _light_dir, float _fog_phase_anisotropy)
{
    float fpa_2 = _fog_phase_anisotropy * _fog_phase_anisotropy;
    float cos_theta = dot(_view_dir, _light_dir);
    return (1/4*M_PI) * (1 - fpa_2) / pow(1+fpa_2-2*_fog_phase_anisotropy*cos_theta, 1.5);
}

float get_ambient_convolved_with_phase_function(vec3 _world_pos, vec3 _view_dir, float _fog_phase_anisotropy)
{
    return 0.0;
}

vec3 get_local_light_dir(uint _light_idx, vec3 _world_pos)
{
    return vec3(0);
}

vec3 get_local_light_radiance(uint _light_idx, vec3 _world_pos)
{
    return vec3(0);
}

void main()
{
    const vec3 world_pos = compute_thread_world_pos().xyz;
    const float layer_thickness = compute_layer_thickness(world_pos.xyz);
    const float dust_density = calculate_density_function(world_pos.xyz);
    // Scattering coefficient
    const float scattering = u_scattering_coefficient * dust_density * layer_thickness;
    // Absorption coefficient
    const float absorption = u_absorption_coefficient * dust_density * layer_thickness;
    
    const vec3 view_dir = normalize(world_pos.xyz - u_fog_cam_world_pos);

    vec3 accum_lighting = vec3(0.0);

    // LIGHTING SECTION
    // Add all contributing lights' radiance and multiplying it by a phase function
    // Volumetric equivalent of BRDFs

    // All direction vectors should be normalized.

    //accum_lighting += get_sun_lighting_radiance(world_pos) * get_phase_function(view_dir, u_sun_dir, u_phase_anisotropy);
    accum_lighting += get_ambient_convolved_with_phase_function(world_pos, view_dir, u_phase_anisotropy);
    
    for(uint light_idx = 0; light_idx < u_pointlight_count; ++light_idx)
    {
        vec3 local_light_dir = get_local_light_dir(light_idx, world_pos);
        accum_lighting += get_local_light_radiance(light_idx, world_pos) * 
            get_phase_function(view_dir, local_light_dir, u_phase_anisotropy);
    }

    // Apply fog scattering albedo.
    accum_lighting *= u_fog_albedo;

    // Final in-scattering is product of outgoing radiance and scattering coefficients,
    // while extinction is sum of scattering and absorption.
    vec4 final_value = vec4(
        accum_lighting * scattering,
        scattering + absorption
    );
    imageStore(u_out_inscattering, ivec3(gl_GlobalInvocationID), final_value);

}